---
title: "R dyntrace report"
author: "K. Siek, A. Goel"
output: 
  html_document:
    theme: flatly # default cerulean journal flatly readable 
                  # spacelab united cosmo lumen paper sandstone simplex yeti
    highlight: tango
    toc: true
    toc_depth: 3
    number_sections: true
params:
  CSV_DIR: "/home/kondziu/workspace/promise-dyntracing-experiment/graphs/csv/"
  PRINT_DATA: TRUE
---

<style>
  .col2 {
    columns: 2 200px;         /* number of columns and width in pixels*/
    -webkit-columns: 2 200px; /* chrome, safari */
    -moz-columns: 2 200px;    /* firefox */
  }
  
  div.together {
    display: inline-block;
    width: 100%;
  }
</style>



``` {r, "initial setup", include=FALSE}
#rmarkdown::render("graphs_from_csv.Rmd", params = list(CSV_DIR = "/home/kondziu/workspace/R-dyntrace/reports/aggregate/", PRINT_DATA = TRUE))
#params <- data.frame(PRINT_DATA=TRUE, CSV_DIR="/home/kondziu/workspace/promise-dyntracing-experiment/graphs/csv/")

#knitr::opts_chunk$set(cache=TRUE)

library(dplyr)
library(hashmap)
library(ggplot2)
library(knitr)
library(kableExtra)
library(scales)
library(gridExtra)
library(png)

SEXP_TYPE_NAMES = c(
    "NIL", "SYM", "LIST", "CLOS", "ENV",  "PROM", # 0-5
    "LANG", "SPECIAL", "BUILTIN", "CHAR",  "LGL", # 6-10
    "INT", "REAL", "CPLX", "STR", "DOT", "ANY",   # 13-18
    "VEC", "EXPR", "BCODE", "EXTPTR", "WEAKREF",  # 19-23
    "RAW", "S4")                                  # 24-25

pp <- function(number) format(number, big.mark=",", scientific=FALSE, trim=FALSE, digits=2)
load_local_csv <- function (csv_file) {
    path <- file.path(params$CSV_DIR, csv_file)
    write(paste("reading", path), stderr())
    as_tibble(read.csv(path, stringsAsFactors=FALSE))
}
print_data <- function (x) if(params$PRINT_DATA) print(x, row.names=FALSE)
prettify <- function(x) x %>% mutate(number=pp_trunc(number), percent=pp_perc(percent)) %>% as.data.frame
pp_trunc <- function(x) ifelse(x==0, paste(format(x, digits=2, scientific=FALSE)),
                               ifelse(x < 1000, format(x, digits=2, scientific=FALSE), 
                                      ifelse(x < 1000000, 
                                             paste(format(floor((x/1000)*10)/10, digits=2, scientific=FALSE), "k", sep=""), 
                                             paste(format(floor((x/1000000)*10)/10, digits=2, scientific=FALSE), "m", sep=""))))
pp_perc <- function(x) dollar_format(prefix="", suffix="%")(x)
is_outlier <- function(x) x < quantile(x, 0.25) - 1.5 * IQR(x) | x > quantile(x, 0.75) + 1.5 * IQR(x)

#http://mathematicalcoffee.blogspot.cz/2014/06/ggpie-pie-graphs-in-ggplot2.html
ggpie <- function (dat, by, totals, labels=by) {
    ggplot(dat, aes_string(x=factor(1), y=totals, fill=by)) +
        geom_bar(stat='identity', color='black') +
        guides(fill=guide_legend(override.aes=list(colour=NA))) + # removes black borders from legend
        coord_polar(theta='y') +
        theme(axis.ticks=element_blank(),
            axis.text.y=element_blank(),
            axis.text.x=element_text(colour='black'),
            axis.title=element_blank(),
            legend.position='none') +
    scale_y_continuous(breaks=cumsum(dat[[totals]]) - dat[[totals]] / 2, labels=dat[[labels]])
}

make_graphs_for_packages <- function(data, f, max.col=10) {
  graphs <- lapply((data %>% select(name) %>% distinct %>% pull(name)), f(data))
  do.call("grid.arrange", c(graphs, ncol=min(max.col, ceiling(sqrt(length(graphs))))))
}

make_graphs_for_range <- function(data, range_column, f, max.col=10) {
  graphs <- lapply(data %>% select(!!range_column) %>% distinct %>% pull(!!range_column),
                   function(x) f(data %>% filter_(paste(range_column,"==",quote(x)))))
  do.call("grid.arrange", c(graphs, ncol=min(length(graphs), max.col)))
}

# hard-coded columns: number
make_graphs_by_split <- function(data, key, split="name", max_columns=10, graphing_function=NA) {
  if (is.na(graphing_function))
    graphing_function <- 
      function(package, data) 
        ggplot(data, aes_string(x=key, y="number")) + 
        geom_bar(stat="identity") +
        scale_y_continuous(
          labels=pp_trunc, 
          breaks=c(max(data$number))) +
        theme(
          axis.title.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.text.y=element_text(angle=90, size=5, vjust=.5),
          axis.text.x=element_text(angle=90, size=5, vjust=.5),
          axis.title.x=element_text(size=5),
          legend.position="none") +
        xlab(package)
    
  packages <- data %>% select_(split) %>% distinct %>% pull(split)
  key_range <- data %>% select_(key) %>% distinct %>% collect
  
  splitter <- function (package)
    graphing_function(
      package,
      data %>% 
        filter(UQ(rlang::sym(split)) == !!package) %>% 
        group_by_(key) %>%
        summarise(number=sum(number)) %>% 
        right_join(key_range, by=key) %>%
        mutate(number=ifelse(is.na(number), 0, number)))
  
  graphs <- lapply(packages, splitter)
  do.call("grid.arrange", c(graphs, ncol=min(max_columns, ceiling(sqrt(length(graphs))))))
}

# hard coded: percent
make_graphs_by_range <- function(data, range_column, max_columns=10, graphing_function=NA) {
  if(is.na(graphing_function))
    graphing_function <- function(data)
      ggplot(data, aes_string(range_column, "percent")) + 
      geom_violin() +
      scale_y_continuous(labels=pp_perc) +
      theme(axis.title.x=element_blank(),
            axis.title.y=element_blank(),
            legend.position="none")
  
  splitter <- function(x) 
    graphing_function(clean_data %>% filter_(paste(range_column, "==", quote(x))))
  
  range <- data %>% select_(range_column) %>% distinct %>% pull(range_column)
  clean_data <- data %>% mutate(percent = ifelse(is.na(percent), 0, percent))
  graphs <- lapply(range, splitter)
  do.call("grid.arrange", c(graphs, ncol=min(length(graphs), max_columns)))
}
```

``` {r, "basic info", include=FALSE}
aggregated_functions <- load_local_csv("aggregated_functions.csv") #

aggregated_functions %>% filter(!is.na(ERR1) || !is.na(ERR2)) %>% print

basic_info <- 
  load_local_csv("basic_info.csv") %>%
  group_by(name) %>%
  summarise(
    datasets=paste(name, collapse=", "),
    n.datasets=n(),
    n.functions=sum(n.functions),
    n.calls=sum(n.calls),
    n.promises=sum(n.promises),
    n.promise.forces=sum(n.promise.forces),
    n.promise.lookups=sum(n.promise.lookups), 
    n.alien.promises=sum(n.alien.promises),
    n.alien.promise.forces=sum(n.alien.promise.forces)
  )

top5_basic_info <- 
  basic_info %>% 
  arrange(desc(n.calls, n.promises, n.promise.accesses, n.functions))%>% head(5)

aggregate_basic_info <- 
  basic_info %>% summarise(
    name="*",
    datasets=paste(name, collapse=", "),
    n.datasets=n(),
    n.functions=(aggregated_functions %>% count %>% pull(n)),
    n.calls=sum(n.calls),
    n.promises=sum(n.promises),
    n.promise.forces=sum(n.promise.forces),
    n.promise.lookups=sum(n.promise.lookups), 
    n.alien.promises=sum(n.alien.promises),
    n.alien.promise.forces=sum(n.alien.promise.forces)
  )

missing_basic_info <- 
  basic_info %>% summarise(
    name="...",
    datasets="...",
    n.datasets="...",
    n.functions="...",
    n.calls="...",
    n.promises="...",
    n.promise.forces="...",
    n.promise.lookups="...", 
    n.alien.promises="...",
    n.alien.promise.forces="..."
  )

 n.packages <- basic_info %>% count %>% pull(n)
 
 # some graphical stuff
 package_figure_width <- 10
 package_figure_columns <- min(7, ceiling(sqrt(n.packages)))
 package_figure_rows <- ceiling(n.packages/package_figure_columns)
 package_figure_height <- ceiling(10/7 * package_figure_rows)
```

# Dataset

```{r, "dataset", echo=FALSE, comment="", row.names=FALSE}
basic_info %>% select(name) %>% distinct %>% pull(name) %>% as.character %>% print(row.names=FALSE)
```

<!--r path -->
# Overview

``` {r, "overview", echo=FALSE, warning=FALSE}
union(top5_basic_info, aggregate_basic_info) %>% 
  mutate(
    n.functions=pp_trunc(n.functions), 
    n.calls=pp_trunc(n.calls), 
    n.promises=pp_trunc(n.promises), 
    n.promise.accesses=pp_trunc(n.promise.forces + n.promise.lookups),
    n.promise.forces=pp_trunc(n.promise.forces),
    n.promise.lookups=pp_trunc(n.promise.lookups)
  ) %>% 
  select(name, n.functions, n.calls, n.promises, 
         n.promise.accesses, n.promise.forces, 
         n.promise.lookups) %>%  
  kable(col.names=c("package", "functions", "calls", "promises",
                    "promise accesses", "promise forces",
                    "promise lookups"), align="lrrrrrr")
```

<div style="font-size: 50%; padding-top: 2em">
**promise force** means the promise is accessed and the code of the promise is executed  
**promise lookup** mean the promise is accessed and the code of the promise is not executed
</div>

<!--div style="font-size: 50%;">
(showing top 5)
</div-->

<!--Alien promises are promises which were created before we began tracing. We don't have all the information regarding them, so we generally ignore them, including in the data below. They also are a subject of a lot of lookups in functions `from base::*`, which we don't record to save disk space.-->

# Promise accesses

```{r, "promise accesses", include=FALSE}
forces <- 
  load_local_csv("fuzzy_forces.csv") %>% 
  group_by(classification) %>% 
  summarise(number=sum(number)) %>% 
  mutate(percent=100*number/sum(number))
```

``` {r, "promise accesses kable", echo=FALSE}
forces %>% prettify %>% kable(col.names=c("classification","number","percentage"), align="lrr")
```

<!--``` {r evaluations-forces-graph, echo=FALSE, comment="", fig.width=10, fig.height=5}
ggplot(forces, aes(x="", y=percent, fill=classification)) + 
  geom_bar(width=1, stat="identity") + 
  #geom_text(aes(y=cumsum(percent)-percent/2, label=classification)) +
  coord_polar("y", start=0) +
  theme(legend.position="right", axis.title.y=element_blank())
```-->

<div style="font-size: 50%; padding-top: 2em">
**promise force** means the promise is accessed and the code of the promise is executed  
**promise lookup** mean the promise is accessed and the code of the promise is not executed
</div>


```{r, "promise accesses forces", include=FALSE}
forces <- 
  load_local_csv("fuzzy_forces.csv")
  
```

## Distribution per package

```{r, "promise accesses forces packages", echo=FALSE, fig.width=10, fig.height=3}
g_class <- function(x, y_axis=FALSE) {
    ggplot(forces %>% filter(classification==x), aes(x=classification, percent)) +
    geom_violin(draw_quantiles = c(.25, .5, .75)) +
    scale_y_continuous(labels=pp_perc) +
    theme(axis.title.x=element_blank(), legend.position="none") +
    ylab("percentage") +
    theme(axis.title.y=if (y_axis) element_text() else element_blank())
}

grid.arrange(
  g_class("accessed 2+ times, forced once", TRUE),
  g_class("accessed once, forced once"),
  g_class("accessed 1+ times, never forced"),
  g_class("never accessed"),
  ncol=4, widths=c(1.1,1,1,1))
```

# Number of accesses to a promise

## Aggregate

``` {r, "number of accesses to a promise, aggregate", echo=FALSE, warning=FALSE, fig.width=10, fig.height=5}
evaluations <- 
  load_local_csv("promise_evaluations.csv") %>%
  group_by(no.of.evaluations) %>% 
  summarise(number=sum(number)) %>% 
  mutate(percent=100*number/sum(number)) %>%
  mutate(labels=no.of.evaluations) %>%
  mutate(no.of.evaluations=as.numeric(as.character(no.of.evaluations))) %>% 
  mutate(no.of.evaluations=ifelse(is.na(no.of.evaluations), 
                                  max(no.of.evaluations, na.rm=TRUE)+1, 
                                  no.of.evaluations)) %>% 
  arrange(no.of.evaluations)
  
ggplot(evaluations, aes(x=no.of.evaluations, y=number)) + 
  geom_col() +
  scale_y_continuous(labels=pp_trunc) +
  scale_x_discrete(limit=0:11, labels=evaluations %>% pull(labels)) +
  theme(axis.title.x=element_blank(), legend.position="none") +
  ylab("No. of promises") + xlab("No. of accesses")
``` 

<div style="font-size: 50%">
Promise types follow the type designations in ``Rinternals.h``.  
</div>

## Distribution per package/vignette

``` {r, "number of accesses to a promise, per package", echo=FALSE, warning=FALSE, fig.width=10, fig.height=5}
evaluations <- load_local_csv("promise_evaluations.csv")
make_graphs_for_range(evaluations, "no.of.evaluations", max.col=6, f=function(data)
  ggplot(data, aes(x=no.of.evaluations, y=percent)) +
    geom_violin(draw_quantiles = c(.25, .5, .75)) +
    scale_y_continuous(labels=pp_perc) +
    theme(axis.title.x=element_blank(), 
          axis.title.y=element_blank(), 
          legend.position="none")
)
```

## Separate results per package/vignette

``` {r, "number of accesses to a promise, separate per package", echo=FALSE, warning=FALSE, fig.width=package_figure_width, fig.height=package_figure_height}
make_graphs_for_packages(load_local_csv("promise_evaluations.csv"), max.col=package_figure_columns, f=function(data) function(package) {
  evaluations <- 
    data %>% 
    filter(name == !!package) %>%
    mutate(percent=100*number/sum(number)) %>%
    mutate(labels=no.of.evaluations) %>%
    mutate(no.of.evaluations=as.numeric(as.character(no.of.evaluations))) %>% 
    mutate(no.of.evaluations=ifelse(is.na(no.of.evaluations), 
                                    max(no.of.evaluations, na.rm=TRUE)+1, 
                                    no.of.evaluations))
  
  evaluations <- 
    tibble(no.of.evaluations=c(0:11)) %>% 
    left_join(evaluations, by="no.of.evaluations") %>%
    mutate(
      number=ifelse(is.na(number), 0, number),
      percent=ifelse(is.na(percent), 0, percent))
  
  ggplot(evaluations, aes(x=no.of.evaluations, y=number)) + 
    geom_col() +
    scale_x_discrete(limit=0:11, labels=c(0:10,">10")) +
    scale_y_continuous(labels=pp_trunc, breaks=c(max(pull(evaluations, number)))) +
    theme(axis.title.y=element_blank(),
          axis.text.y=element_text(angle=90, size=5, vjust=.5),
          axis.ticks.y=element_blank(),
          axis.text.x=element_text(angle=90, size=5, vjust=.5),
          axis.title.x=element_text(size=5),
          legend.position="none") +
    xlab(package)
})
``` 

# Promise code types

## Aggregate

``` {r, "promise code types, aggregate", echo=FALSE, fig.width=10, fig.height=5}
promise_types <- 
  load_local_csv("promise_types.csv")

ggplot(promise_types %>% group_by(type) %>% summarise(number=sum(number)) %>% mutate(percent=100*number/sum(number)), 
       aes(x=type, y=number)) + 
  geom_col() +
  scale_y_continuous(labels=pp_trunc) +
  theme(axis.title.x=element_blank(), 
        legend.position="none", 
        axis.text.x=element_text(angle=90, vjust=.5)) +
  ylab("No. of promises") + 
  xlab("Promise type")
```

<div style="font-size: 50%">
Promise types follow the type designations in ``Rinternals.h``.  
<!--**α→β** indicates that type **α** variously evaluates to type **β**.
**α** indicates that the promise contains the expression of type **α**.  
**→α** indicates that the promise contains a promise which contains the expression of type **α**, etc.
**BCODE →α** indicates that it's a byte-compiled expression that was originally of type **α**.  
**SYM→α** indicates that it's a symbol that points to an expression of type **α**.  -->
</div>

## Distribution per package/vignette

``` {r, "promise code types, per package", echo=FALSE, warning=FALSE, fig.width=10, fig.height=5}
make_graphs_for_range(promise_types, "type", max.col=5, f=function(data)
  ggplot(data, aes(x=type, y=percent)) +
    geom_violin(draw_quantiles = c(.25, .5, .75)) +
    scale_y_continuous(labels=pp_perc) +
    theme(axis.title.x=element_blank(), 
          axis.title.y=element_blank(), 
          legend.position="none")
)
```

## Separate results per package/vignette

``` {r, "promise code types, separate per package", echo=FALSE, warning=FALSE, fig.width=package_figure_width, fig.height=package_figure_height}
available_sexps <- promise_types %>% select(type) %>% distinct %>% pull(type)

make_graphs_for_packages(promise_types, max.col=package_figure_columns, f=function(data) function(package) {
  promise_types <- 
    data %>% 
    filter(name == !!package) %>%
    group_by(type) %>% summarise(number=sum(number)) %>% 
    mutate(percent=100*number/sum(number))
  
  promise_types <- 
    tibble(type=available_sexps) %>% 
    left_join(promise_types, by="type") %>%
    mutate(
      number=ifelse(is.na(number), 0, number),
      percent=ifelse(is.na(percent), 0, percent))
 
  ggplot(promise_types, aes(x=type, y=number)) + 
    geom_col() +
    scale_y_continuous(labels=pp_trunc, breaks=c(max(pull(promise_types, number)))) +
    theme(axis.title.y=element_blank(),
          axis.text.y=element_text(angle=90, size=5, vjust=.5),
          axis.ticks.y=element_blank(),
          axis.text.x=element_text(angle=90, size=5, vjust=.5),
          axis.title.x=element_text(size=5),
          legend.position="none") +
    xlab(package)
})
``` 

# Type traces

```{r, "what's inside promises", echo=FALSE, fig.width=10, fig.height=4.5}
promise_full_types <-
  load_local_csv("promise_full_types.csv") %>%
  group_by(type) %>% 
  summarise(number=sum(number)) %>% 
  mutate(percent=100*number/sum(number)) %>% 
  mutate(type=as.character(type)) #%>%
  #filter(grepl("^PROM", type)) %>%
  #mutate(type=gsub("PROM", "", type))
  #mutate(type=ifelse(len(type) > 15, paste0(strtrim(type, 13), ".."), type))

promise_full_types %>% 
  arrange(desc(number)) %>%
  mutate(number=pp_trunc(number), percent=pp_perc(percent)) %>%
  select(number, percent, type) %>%
  kable(col.names=c("number", "percent", "type trace"), align="lll")
```

<div style="font-size: 50%">
Promise types follow the type designations in ``Rinternals.h``.  
<!--**α→β** indicates that type **α** variously evaluates to type **β**.  -->
**α** indicates that the promise contains the expression of type **α**.  
**PROM→α** indicates that the promise contains a promise which contains the expression of type **α**, etc.  
**BCODE →α** indicates that it's a byte-compiled expression that was originally of type **α**.    
**SYM→α** indicates that it's a symbol that points to an expression of type **α**.  
**...** is a type that could not has not been correctly determined.
</div>

# Promise return types

## Aggregate

``` {r, "promise return types, aggregate",  echo=FALSE, fig.width=10, fig.height=5}
return_types <- 
  load_local_csv("return_types.csv")

ggplot(return_types %>%   
         group_by(type) %>% 
         summarise(number=sum(number)) %>% 
         mutate(percent=100*number/sum(number)), 
       aes(x=type, y=number)) + 
  geom_col() +
  scale_y_continuous(labels=pp_trunc) +
  theme(axis.title.x=element_blank(), 
        legend.position="none", 
        axis.text.x=element_text(angle=90, vjust=.5, hjust=1)) +
  ylab("No. of promises") + 
  xlab("Return type")
```

<div style="font-size: 50%">
Promise types follow the type designations in ``Rinternals.h``.  
</div>

## Distribution per package/vignette

``` {r, "promise return types, per package", echo=FALSE, warning=FALSE, fig.width=10, fig.height=7}
#make_graphs_for_range(return_types, "type", max.col=5, f=function(data)
#  ggplot(data, aes(x=type, y=percent)) +
#    geom_violin(draw_quantiles = c(.25, .5, .75)) +
#    scale_y_continuous(labels=pp_perc) +
#    theme(axis.title.x=element_blank(), 
#          axis.title.y=element_blank(), 
#          legend.position="none")
#)
```

## Separate results per package/vignette

``` {r, "promise return types, separate per package", echo=FALSE, warning=FALSE, fig.width=package_figure_width, fig.height=package_figure_height}
available_sexps <- return_types %>% select(type) %>% distinct %>% pull(type)

make_graphs_for_packages(return_types, max.col=package_figure_columns, f=function(data) function(package) {
  promise_types <- 
    data %>% 
    filter(name == !!package) %>%
    group_by(type) %>% summarise(number=sum(number)) %>% 
    mutate(percent=100*number/sum(number))
  
  promise_types <- 
    tibble(type=available_sexps) %>% 
    left_join(promise_types, by="type") %>%
    mutate(
      number=ifelse(is.na(number), 0, number),
      percent=ifelse(is.na(percent), 0, percent))
 
  ggplot(promise_types, aes(x=type, y=number)) + 
    geom_col() +
    scale_y_continuous(labels=pp_trunc, breaks=c(max(pull(promise_types, number)))) +
    theme(axis.title.y=element_blank(),
          axis.text.y=element_text(angle=90, size=5, vjust=.5),
          axis.ticks.y=element_blank(),
          axis.text.x=element_text(angle=90, size=5, vjust=.5),
          axis.title.x=element_text(size=5),
          legend.position="none") +
    xlab(package)
})
``` 

## What do specific promises return?

```{r, "what do specific promises return", echo=FALSE, comment="", fig.width=10.5, fig.height=4.5}
types_to_return_types <- 
  load_local_csv("promise_code_to_return_types.csv") %>%
  group_by(types) %>% 
  summarise(number=sum(number)) %>% 
  mutate(percent=100*number/sum(number)) %>%
  arrange(desc(number))

ggplot(types_to_return_types, aes(x=types, y=number)) + 
  geom_col() +
  scale_y_continuous(labels=pp_trunc) +
  theme(axis.title.x=element_blank(), 
        axis.title.y=element_blank(),
        legend.position="none", 
        axis.text.x=element_text(angle=90, vjust=.5, hjust=1)) +
  ylab("No. of promises") + 
  xlab("Type/return type")
```

<div style="font-size: 50%">
Promise types follow the type designations in ``Rinternals.h``.  
**α→β** indicates that the promise contains an expression of type **α** which evaluates to  an expression of type **β** when the promise is forced.
</div>

# Promise forces by types

## Aggregate

```{r, "promise forces by types, aggregate",  echo=FALSE, , comment="", fig.width=10, fig.height=5}
force.histogram.by.type <- load_local_csv("forces_by_type.csv") 

ggplot(
  force.histogram.by.type %>%
    group_by(type, no.of.forces) %>% 
    summarise(number=sum(number)) %>% 
    mutate(percent=100*number/sum(number)), 
  aes(x=type, y=number, fill=factor(no.of.forces))) + 
geom_bar(stat="identity", position="dodge") +
ylab("No. of promises") + 
scale_fill_discrete(name="No. of forces",
                    breaks=(force.histogram.by.type$no.of.forces %>% unique),
                    labels=(force.histogram.by.type$no.of.forces %>% unique)) +
scale_y_continuous(labels=pp_trunc) +
theme(axis.title.x=element_blank(), legend.position = c(0.9, 0.9))
```

<div style="font-size: 50%">
Promise types follow the type designations in ``Rinternals.h``.
</div>

## Distribution per package

```{r, "promise forces by types, per package", echo=FALSE, warning=FALSE, fig.width=10, fig.height=10}

types <- force.histogram.by.type %>% pull(type) %>% unique
forces <- force.histogram.by.type %>% pull(no.of.forces) %>% unique
featured_packages <- force.histogram.by.type %>% pull(name) %>% unique

force_histogram_filled_in <- 
  expand.grid(type=types, no.of.forces=forces, name=featured_packages) %>%
  left_join(force.histogram.by.type, by=c("type", "no.of.forces", "name")) %>%
  mutate(number=ifelse(is.na(number), 0, number),
         percent=ifelse(is.na(percent_overall), 0, percent_overall)) %>%
  mutate(forces=paste0(type, "/", no.of.forces)) %>%
  #select(forces, number, percent, name) %>% 
  arrange(forces) %>% 
  as_tibble

make_graphs_for_range(force_histogram_filled_in, "forces", max.col=5,
  f=function(data) 
    ggplot(data, aes(x=forces, y=percent)) +
    geom_violin() +
    #geom_violin(draw_quantiles=c(.25, .5, .75)) + # this one errors out and idk why
    scale_y_continuous(labels=pp_perc) +
    theme(axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          legend.position="none")
)
```

## Separate results per package/vignette

``` {r, "promise forces by types, separate per package", echo=FALSE, warning=FALSE, fig.width=package_figure_width, fig.height=package_figure_height}
#type_range <- force_histogram_filled_in %>% select(type) %>% distinct %>% pull(forces)

make_graphs_for_packages(force_histogram_filled_in, max.col=package_figure_columns, f=function(data) function(package) {
  force_histogram <- 
    data %>% 
    filter(name == !!package) %>%
    group_by(type, no.of.forces) %>% 
      summarise(number=sum(number)) %>% 
      mutate(percent=100*number/sum(number))
    #group_by(type) %>% summarise(number=sum(number)) %>% 
    #mutate(percent=100*number/sum(number))
  
  ggplot(
    force_histogram,
    aes(x=type, y=number, fill=factor(no.of.forces))) + 
    geom_bar(stat="identity", position="dodge") +
    scale_y_continuous(labels=pp_trunc, breaks=c(max(pull(force_histogram, number)))) +
    theme(axis.title.y=element_blank(),
          axis.text.y=element_text(angle=90, size=5, vjust=.5),
          axis.ticks.y=element_blank(),
          axis.text.x=element_text(angle=90, size=5, vjust=.5),
          axis.title.x=element_text(size=5),
          legend.position="none") +
    xlab(package)
})
``` 

# Promise evaluation distances

## Aggregate

<!--Effective distance is the distance from the call where a promise originated to the call in which it was evaluated. It is measured along the call graph (along inbound edges).  Since the data is gathered from a trace, the call graph is a tree.-->

```{r, "promise actual distances, aggregate", echo=FALSE, fig.width=10, fig.height=4.5}
actual_distances <- load_local_csv("actual_distances.csv") 

ggplot(actual_distances %>% 
         group_by(actual_distance) %>% 
         summarise(number=sum(number, na.rm=TRUE)) %>% 
         mutate(percent=100*number/sum(number)), aes(x=actual_distance, y=number)) + 
  geom_col() +
  scale_x_discrete(limits=c(NA,0:20,">20",-1)) +
  scale_y_continuous(labels=pp_trunc) +
  ylab("No. of promises") + 
  theme(axis.title.x=element_blank())
```

<div style="font-size: 50%">
**n** - distance from the function for which a promise was created and the function in which it was evaluated    
**NA** - promise was not executed, there is no distance measure (a virgin promise)  
**-1** - promise was executed but there is no path from the origin to the point of evaluation (an escaped promise)    
</div>

## Distribution per package/vignette

``` {r, "promise actual distances, per package", echo=FALSE, warning=FALSE, fig.width=10, fig.height=7}
make_graphs_for_range(actual_distances %>%
  mutate(actual_distance = ifelse(is.na(actual_distance), "NA", actual_distance)),
  "actual_distance", max.col=5, f=function(data)
  ggplot(data, aes(x=actual_distance, y=percent)) + 
  geom_violin() +
  scale_y_continuous(labels=pp_perc) +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        legend.position="none")
)
```

## Separate results per package/vignette

``` {r, "promise evaluation distance, separate per package", echo=FALSE, warning=FALSE, fig.width=package_figure_width, fig.height=package_figure_height}
range <- actual_distances %>% select(actual_distance) %>% distinct %>% pull(actual_distance)

make_graphs_for_packages(actual_distances, max.col=package_figure_columns, f=function(data) function(package) {
  package_data <- 
    data %>% 
    filter(name == !!package) %>%
    group_by(actual_distance) %>% 
    summarise(number=sum(number)) %>% 
    mutate(percent=100*number/sum(number))
  
  package_data <- 
    tibble(actual_distance=range) %>% 
    left_join(package_data, by="actual_distance") %>%
    mutate(
      number=ifelse(is.na(number), 0, number),
      percent=ifelse(is.na(percent), 0, percent))
  
  ggplot(package_data, aes(x=actual_distance, y=number)) + 
    geom_bar(stat="identity") +
    scale_y_continuous(labels=pp_trunc, breaks=c(max(package_data$number))) +
    theme(axis.title.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.text.y=element_text(angle=90, size=5, vjust=.5),
          axis.text.x=element_text(angle=90, size=5, vjust=.5),
          axis.title.x=element_text(size=5),
          legend.position="none") +
    xlab(package)
})
``` 

# Calls and functions by type

## Aggregate

<center>
<div class="col2">
<div class="together">
```{r, "calls by type", echo=FALSE, fig.width=5, fig.height=4}
calls_types <- load_local_csv("call_types.csv")

data <- 
  calls_types %>% 
  group_by(type) %>% 
  summarise(number=sum(number)) %>% 
  mutate(percent=100*number/sum(number))
  
ggplot(data, aes(x=type, y=number)) + 
  geom_bar(stat="identity") +
  ylab("No. of calls") + 
  scale_y_continuous(labels=pp_trunc) +
  theme(axis.title.x=element_blank())
```
</div>

```{r, "functions by type", echo=FALSE, fig.width=5, fig.height=4}
function_types <- load_local_csv("aggregated_function_types.csv")
  
data <- function_types %>%
  group_by(type) %>% 
  summarise(number=sum(number)) %>% 
  mutate(percent=100*number/sum(number)) 

ggplot(data, aes(x=type, y=number)) + 
  geom_bar(stat="identity") +
  ylab("No. of function definitions") + 
  scale_y_continuous(labels=pp_trunc) +
  theme(axis.title.x=element_blank())
```
</div>
</center>

<div style="font-size: 50%">
**functions** refers to function definitions   
**calls** refers to function executions/calls
</div>

## Calls by type, distribution per package/vignette

``` {r, "calls by type, per package", echo=FALSE, warning=FALSE, fig.width=10, fig.height=5}
make_graphs_for_range(calls_types %>% mutate(percent = ifelse(is.na(percent), 0, percent)),
  "type", max.col=5, f=function(data)
  ggplot(data, aes(x=type, y=percent)) + 
  geom_violin() +
  scale_y_continuous(labels=pp_perc) +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        legend.position="none")
)
```

## Functions by type, distribution per package/vignette

``` {r, "functions by type, per package", echo=FALSE, warning=FALSE, fig.width=10, fig.height=5}
make_graphs_for_range(function_types %>% mutate(percent = ifelse(is.na(percent), 0, percent)),
  "type", max.col=5, f=function(data)
  ggplot(data, aes(x=type, y=percent)) + 
  geom_violin() +
  scale_y_continuous(labels=pp_perc) +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        legend.position="none")
)
```

## Calls by type, separate results per package/vignette

``` {r, "calls by type, separate per package", echo=FALSE, warning=FALSE, fig.width=package_figure_width, fig.height=package_figure_height}
range <- calls_types %>% select(type) %>% distinct %>% pull(type)
make_graphs_for_packages(calls_types, max.col=package_figure_columns, f=function(data) function(package) {
  package_data <- 
    data %>% 
    filter(name == !!package) %>%
    group_by(type) %>% 
    summarise(number=sum(number)) %>% 
    mutate(percent=100*number/sum(number))
  
  package_data <- 
    tibble(type=range) %>% 
    left_join(package_data, by="type") %>%
    mutate(
      number=ifelse(is.na(number), 0, number),
      percent=ifelse(is.na(percent), 0, percent))
  
  ggplot(package_data, aes(x=type, y=number)) + 
    geom_bar(stat="identity") +
    scale_y_continuous(labels=pp_trunc, breaks=c(max(package_data$number))) +
    theme(axis.title.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.text.y=element_text(angle=90, size=5, vjust=.5),
          axis.text.x=element_text(angle=90, size=5, vjust=.5),
          axis.title.x=element_text(size=5),
          legend.position="none") +
    xlab(package)
})
``` 

## Functions by type, separate results per package/vignette

``` {r, "functions by type, separate per package", echo=FALSE, warning=FALSE, fig.width=package_figure_width, fig.height=package_figure_height}
range <- function_types %>% select(type) %>% distinct %>% pull(type)
make_graphs_for_packages(function_types, max.col=package_figure_columns, f=function(data) function(package) {
  package_data <- 
    data %>% 
    filter(name == !!package) %>%
    group_by(type) %>% 
    summarise(number=sum(number)) %>% 
    mutate(percent=100*number/sum(number))
  
  package_data <- 
    tibble(type=range) %>% 
    left_join(package_data, by="type") %>%
    mutate(
      number=ifelse(is.na(number), 0, number),
      percent=ifelse(is.na(percent), 0, percent))
  
  ggplot(package_data, aes(x=type, y=number)) + 
    geom_bar(stat="identity") +
    scale_y_continuous(labels=pp_trunc, breaks=c(max(package_data$number))) +
    theme(axis.title.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.text.y=element_text(angle=90, size=5, vjust=.5),
          axis.text.x=element_text(angle=90, size=5, vjust=.5),
          axis.title.x=element_text(size=5),
          legend.position="none") +
    xlab(package)
})
``` 

# Byte-code compilation

## Aggregate

<center>
<div class="col2">
<div class="together">
```{r, "byte-code compilation, calls", echo=FALSE, fig.width=5, fig.height=3.5, warning=FALSE}
closure_call_compilation <- load_local_csv("compiled_calls.csv")

data <- 
  closure_call_compilation %>% 
  group_by(compiled) %>% 
  summarise(number=sum(number)) %>% 
  mutate(percent=100*number/sum(number))
  
ggplot(data, aes(x=compiled, y=number)) + 
  geom_bar(stat="identity") +
  ylab("No. of calls") + 
  scale_y_continuous(labels=pp_trunc) +
  theme(axis.title.x=element_blank())
```
</div>

```{r, "byte-code compilation, functions", echo=FALSE, fig.width=5, fig.height=3.5, warning=FALSE}
closure_function_compilation <- load_local_csv("aggregated_compiled_functions.csv")

data <- 
  closure_function_compilation %>% 
  group_by(compiled) %>% 
  summarise(number=sum(number)) %>% 
  mutate(percent=100*number/sum(number))
  
ggplot(data, aes(x=compiled, y=number)) + 
  geom_bar(stat="identity") +
  ylab("No. of calls") + 
  scale_y_continuous(labels=pp_trunc) +
  theme(axis.title.x=element_blank())
```

```{r, "byte-code compilation, functions loading", echo=FALSE, warning=FALSE}
closure_function_compilation <- load_local_csv("compiled_functions.csv")
```

</div>
</center>

<div style="font-size: 50%">
When calling a function it's either byte-code **compiled** or **uncompiled**. When agregated across all calls to a function, a function can be:  
**compiled** - all calls to this function are compiled,  
**uncompiled** - none of the calls to this function are compiled,  
**after 1st** - a function can be compiled by the JIT, so it can be uncompiled initially and then compiled later on,  
**erratic** - a function is sometimes compiled and sometimes not; it can indicate that two separate functions are indistinguishable to the tracer (same definition, unknown location) and one of them is compiled while another is not.
</div>

## Compiled calls, distribution per package/vignette

``` {r, "byte-code compilation, calls, per package", echo=FALSE, warning=FALSE, fig.width=10, fig.height=5}
make_graphs_for_range(closure_call_compilation %>% mutate(percent = ifelse(is.na(percent), 0, percent)),
  "compiled", max.col=5, f=function(data)
  ggplot(data, aes(x=compiled, y=percent)) + 
  geom_violin() +
  scale_y_continuous(labels=pp_perc) +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        legend.position="none")
)
```

## Compiled functions, distribution per package/vignette

``` {r, "byte-code compilation, functions, per package", echo=FALSE, warning=FALSE, fig.width=10, fig.height=5}
make_graphs_for_range(closure_function_compilation %>% mutate(percent = ifelse(is.na(percent), 0, percent)),
  "compiled", max.col=5, f=function(data)
  ggplot(data, aes(x=compiled, y=percent)) + 
  geom_violin() +
  scale_y_continuous(labels=pp_perc) +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        legend.position="none")
)
```

## Compiled calls, separate results per package/vignette

``` {r, "compiled calls, separate per package", echo=FALSE, warning=FALSE, fig.width=package_figure_width, fig.height=package_figure_height}
range <- closure_call_compilation %>% select(compiled) %>% distinct %>% pull(compiled)
make_graphs_for_packages(closure_call_compilation, max.col=package_figure_columns, f=function(data) function(package) {
  package_data <- 
    data %>% 
    filter(name == !!package) %>%
    group_by(compiled) %>% 
    summarise(number=sum(number)) %>% 
    mutate(percent=100*number/sum(number))
  
  package_data <- 
    tibble(compiled=range) %>% 
    left_join(package_data, by="compiled") %>%
    mutate(
      number=ifelse(is.na(number), 0, number),
      percent=ifelse(is.na(percent), 0, percent))
  
  ggplot(package_data, aes(x=compiled, y=number)) + 
    geom_bar(stat="identity") +
    scale_y_continuous(labels=pp_trunc, breaks=c(max(package_data$number))) +
    theme(axis.title.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.text.y=element_text(angle=90, size=5, vjust=.5),
          axis.text.x=element_text(angle=90, size=5, vjust=.5),
          axis.title.x=element_text(size=5),
          legend.position="none") +
    xlab(package)
})
``` 

## Compiled functions, separate results per package/vignette

``` {r, "compiled functions, separate per package", echo=FALSE, warning=FALSE, fig.width=package_figure_width, fig.height=package_figure_height}
range <- closure_function_compilation %>% select(compiled) %>% distinct %>% pull(compiled)
make_graphs_for_packages(closure_function_compilation, max.col=package_figure_columns, f=function(data) function(package) {
  package_data <- 
    data %>% 
    filter(name == !!package) %>%
    group_by(compiled) %>% 
    summarise(number=sum(number)) %>% 
    mutate(percent=100*number/sum(number))
  
  package_data <- 
    tibble(compiled=range) %>% 
    left_join(package_data, by="compiled") %>%
    mutate(
      number=ifelse(is.na(number), 0, number),
      percent=ifelse(is.na(percent), 0, percent))
  
  ggplot(package_data, aes(x=compiled, y=number)) + 
    geom_bar(stat="identity") +
    scale_y_continuous(labels=pp_trunc, breaks=c(max(package_data$number))) +
    theme(axis.title.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.text.y=element_text(angle=90, size=5, vjust=.5),
          axis.text.x=element_text(angle=90, size=5, vjust=.5),
          axis.title.x=element_text(size=5),
          legend.position="none") +
    xlab(package)
})
``` 

# Interactions among promises

```{r, "interactions among poromises", echo=FALSE, comment="", fig.width=10, fig.height=4.5}
# Graph one
promises_forced_by_another_promise <-   
  load_local_csv("promises_forced_by_another_promise.csv")
  
g_receive <- 
  ggplot(promises_forced_by_another_promise %>% 
    group_by(forced_by_another) %>% 
    summarise(number=sum(number)) %>% 
    mutate(percent=100*number/sum(number)), 
  aes(x=forced_by_another, y=number)) + 
  geom_col() +
  scale_y_continuous(labels=pp_trunc) +
  theme(legend.position="none") +
  ylab("No. of promises") + 
  xlab("This promise forced\nby another promise")

# Graphs two and three
promises_forcing_other_promises <- 
  load_local_csv("promises_forcing_other_promises.csv")

promises_forcing_other_promises_summarized <- 
  promises_forcing_other_promises %>%
  group_by(number_of_forced_promises) %>% 
  summarise(number=sum(number)) %>% 
  mutate(percent=100*number/sum(number))

# Graph two
promises_forcing_other_promises_small <-
  promises_forcing_other_promises_summarized %>% 
  mutate(number_of_forced_promises=ifelse(number_of_forced_promises>=3, "3+", 
                                          number_of_forced_promises)) %>%
  group_by(number_of_forced_promises) %>%
  summarise(number=sum(number)) %>% 
  mutate(percent=100*number/sum(number))

g_cause_small <- 
  ggplot(promises_forcing_other_promises_small, aes(x=number_of_forced_promises, y=number)) + 
  geom_col() +
  scale_y_continuous(labels=pp_trunc) +
  ylab("No. of promises") + 
  xlab("No. of promises forced\nby this promise") +
  theme(legend.position="none", axis.title.y=element_blank())

# Graph three
promises_forcing_other_promises_big <-
  promises_forcing_other_promises_summarized %>% 
  filter(number_of_forced_promises >= 3) %>%
  group_by(number_of_forced_promises) %>%
  summarise(number=sum(number)) %>% 
  mutate(percent=100*number/sum(number))

g_cause_big <- 
  ggplot(promises_forcing_other_promises_big, aes(x=number_of_forced_promises, y=number)) + 
  geom_col() +
  scale_y_continuous(labels=pp_trunc) +
  ylab("No. of promises") + 
  xlab("No. of promises forced\nby this promise (3+)") +
  theme(legend.position="none", axis.title.y=element_blank())
  
# Drawing
grid.arrange(g_receive, g_cause_small, g_cause_big, ncol=3, widths=c(4,5,9))
```

<div style="font-size: 50%">
Promises forced by other promises:  
`TRUE` is when a promise was created within some promise x but was forced within a different promise y.   
`FALSE` is when a promise was forced within the same promise as it was created.  
`NA` means the promise was not forced.  
</div>

## Promises forced by another promise, distribution per package

``` {r, "promises forced by another promise, per package", echo=FALSE, warning=FALSE, fig.width=10, fig.height=5}
make_graphs_for_range(
  promises_forced_by_another_promise %>% 
    mutate(percent = ifelse(is.na(percent), 0, percent)) %>%
    mutate(forced_by_another = ifelse(is.na(forced_by_another), "NA", forced_by_another)),
  "forced_by_another", max.col=5, f=function(data)
  ggplot(data, aes(x=forced_by_another, y=percent)) + 
  geom_violin() +
  scale_y_continuous(labels=pp_perc) +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        legend.position="none")
)
```

## Promises forcing other promises, distribution per package

``` {r, "promises forcing other promises, per package", echo=FALSE, warning=FALSE, fig.width=10, fig.height=5}
promises_forcing_other_promises_small_per_package <-
  promises_forcing_other_promises %>% 
  mutate(number_of_forced_promises=ifelse(number_of_forced_promises>=3, "3+", 
                                          number_of_forced_promises)) %>%
  group_by(name, number_of_forced_promises) %>%
  summarise(number=sum(number), percent=sum(percent)) %>%
  ungroup
  
make_graphs_for_range(
  promises_forcing_other_promises_small_per_package %>% 
    mutate(percent = ifelse(is.na(percent), 0, percent)) %>%
    mutate(number_of_forced_promises = ifelse(is.na(number_of_forced_promises), "NA", number_of_forced_promises)),
  "number_of_forced_promises", max.col=5, f=function(data)
  ggplot(data, aes(x=number_of_forced_promises, y=percent)) + 
  geom_violin() +
  scale_y_continuous(labels=pp_perc) +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        legend.position="none")
)
```

## Promises forced by another promise, separate results per package/vignette

``` {r, "promises forced by another promise, separate per package", echo=FALSE, warning=FALSE, fig.width=package_figure_width, fig.height=package_figure_height}
range <- promises_forced_by_another_promise %>% select(forced_by_another) %>% distinct %>% pull(forced_by_another)
make_graphs_for_packages(promises_forced_by_another_promise, max.col=package_figure_columns, f=function(data) function(package) {
  package_data <- 
    data %>% 
    filter(name == !!package) %>%
    group_by(forced_by_another) %>% 
    summarise(number=sum(number)) %>% 
    mutate(percent=100*number/sum(number))
  
  package_data <- 
    tibble(forced_by_another=range) %>% 
    left_join(package_data, by="forced_by_another") %>%
    mutate(
      number=ifelse(is.na(number), 0, number),
      percent=ifelse(is.na(percent), 0, percent))
  
  ggplot(package_data, aes(x=forced_by_another, y=number)) + 
    geom_bar(stat="identity") +
    scale_y_continuous(labels=pp_trunc, breaks=c(max(package_data$number))) +
    theme(axis.title.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.text.y=element_text(angle=90, size=5, vjust=.5),
          axis.text.x=element_text(angle=90, size=5, vjust=.5),
          axis.title.x=element_text(size=5),
          legend.position="none") +
    xlab(package)
})
``` 

## Promises forcing other promises, separate results per package/vignette

``` {r, "promises forcing other promises, separate per package", echo=FALSE, warning=FALSE, fig.width=package_figure_width, fig.height=package_figure_height}
range <- promises_forcing_other_promises_small_per_package %>% select(number_of_forced_promises) %>% distinct %>% pull(number_of_forced_promises)
make_graphs_for_packages(promises_forcing_other_promises_small_per_package, max.col=package_figure_columns, f=function(data) function(package) {
  package_data <- 
    data %>% 
    filter(name == !!package) %>%
    group_by(number_of_forced_promises) %>% 
    summarise(number=sum(number)) %>% 
    mutate(percent=100*number/sum(number))
  
  package_data <- 
    tibble(number_of_forced_promises=range) %>% 
    left_join(package_data, by="number_of_forced_promises") %>%
    mutate(
      number=ifelse(is.na(number), 0, number),
      percent=ifelse(is.na(percent), 0, percent))
  
  ggplot(package_data, aes(x=number_of_forced_promises, y=number)) + 
    geom_bar(stat="identity") +
    scale_y_continuous(labels=pp_trunc, breaks=c(max(package_data$number))) +
    theme(axis.title.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.text.y=element_text(angle=90, size=5, vjust=.5),
          axis.text.x=element_text(angle=90, size=5, vjust=.5),
          axis.title.x=element_text(size=5),
          legend.position="none") +
    xlab(package)
})
``` 

# Call and function definition strictness

## Aggregate

```{r, "call strictnes", echo=FALSE, fig.width=10, fig.height=4.5}
strictness_labeller <- function(x) 
  filter(x, number>0) %>%
  mutate(label=ifelse(is.na(strict),  
                      ifelse(type=="closure", 
                             "closure\n(no arguments)", 
                             type),  
                      ifelse(strict, 
                             paste0(type, "\n(strict)"),
                             paste0(type, "\n(non-strict)"))))

strict_closure_calls <- 
  load_local_csv("call_strictness_by_type.csv") %>%
  strictness_labeller

strict_closure_calls_aggregate <- 
  strict_closure_calls %>%
  group_by(label) %>% 
  summarise(number=sum(number)) %>% 
  mutate(percent=100*number/sum(number)) 

ggplot(strict_closure_calls_aggregate, aes(x=label, y=number)) + 
  ggtitle("Call strictness") +
  geom_col() +
  scale_y_continuous(labels=pp_trunc) +
  theme(legend.position="none", axis.title.x=element_blank()) +
  ylab("No. of calls") 
```

```{r, "function strictnes", echo=FALSE, fig.width=10, fig.height=4.5}
strict_closure_functions <-
  load_local_csv("aggregated_function_strictness_by_type.csv") %>%
  strictness_labeller

strict_closure_functions_aggregate <-
  strict_closure_functions %>%
  group_by(label) %>%
  summarise(number=sum(number)) %>%
  mutate(percent=100*number/sum(number))
 
ggplot(strict_closure_functions_aggregate, aes(x=label, y=number)) +
  ggtitle("Function strictness") +
  geom_col() +
  scale_y_continuous(labels=pp_trunc) +
  theme(legend.position="none", axis.title.x=element_blank()) +
  xlab("Function strictness (closures)")
```

```{r, "function strictnes load", echo=FALSE}
strict_closure_functions <-
  load_local_csv("function_strictness_by_type.csv") %>% 
  strictness_labeller
```


<div style="font-size: 50%">
A call is **strict** if all of its arguments are **evaluated** and none of the arguments is **escaped**. (This means that a function may pass unevaluated promises to a child call and still be strict, but it cannot leak the promise).  
A function is **strict** if all of its calls are **strict**. Functions that don't take promises are neither **strict** nor **non-strict** -- these can be either arrity-0 closures or built-in (which accept values rather than promises).
</div>

## Call strictness, distribution per package/vignette

``` {r, "call strictness, per package", echo=FALSE, warning=FALSE, fig.width=10, fig.height=3}
make_graphs_by_range(strict_closure_calls, range_column="label", max_columns=6)
```

## Function strictness, distribution per package/vignette

``` {r, "function strictness, per package", echo=FALSE, warning=FALSE, fig.width=10, fig.height=3}
make_graphs_by_range(strict_closure_functions, range_column="label", max_columns=6)
```

## Call strictness, separate results per package/vignette

``` {r, "call strictness, separate per package", echo=FALSE, warning=FALSE, fig.width=package_figure_width, fig.height=package_figure_height}
make_graphs_by_split(strict_closure_calls, key="label", max_columns=package_figure_columns)
``` 

## Function strictness, separate results per package/vignette

``` {r, "function strictness, separate per package", echo=FALSE, warning=FALSE, fig.width=package_figure_width, fig.height=package_figure_height}
make_graphs_by_split(strict_closure_functions, key="label", max_columns=package_figure_columns)
``` 

# Call strictness ratio

```{r, "strict calls ratio breakdown", echo=FALSE, fig.width=10, fig.height=4.5}
# strict_calls_ratio <- load_local_csv("call_strictness_ratio.csv")
# 
# strict_calls_ratio_split_arg <- strict_calls_ratio %>% 
#   mutate(evaluated_args=lapply(strsplit(strictnesss_ratio, "/"), `[[`, 1),
#          total_args=lapply(strsplit(strictnesss_ratio, "/"), `[[`, 2))
# 
# range <- strict_calls_ratio_split_arg %>% select(total_args) %>% distinct %>% arrange(total_args) %>% top(20)
# strict_calls_
```

## Call strictness ratios

```{r, "strict calls ratio", echo=FALSE, fig.width=10, fig.height=4.5}
strict_calls_ratio <- 
  load_local_csv("call_strictness_ratio.csv")

threshold = strict_calls_ratio %>% 
  group_by(strictness_ratio) %>% 
  summarise(number=sum(number)) %>% 
  select(number) %>% 
  arrange(desc(number)) %>% 
  head(8) %>% 
  pull(number) %>% 
  min

strict_calls_ratio_labelled <- 
  strict_calls_ratio %>%
  group_by(strictness_ratio) %>% 
  summarise(number=sum(number), 
            percent=(100*number/sum(number))) %>% 
  mutate(short=ifelse(number >= threshold, 
                      as.character(strictness_ratio), 
                      "other"))

ggplot(strict_calls_ratio_labelled %>% 
    group_by(short) %>% 
    summarize(number=sum(number)),
  aes(x=short, y=number)) +
  geom_col() +
  scale_y_continuous(labels=pp_trunc) +
  theme(legend.position="none") +
  ylab("No. of calls") +
  xlab("Ratio of evaluated promises (evaluated args/total args)")
```

<div style="font-size: 50%">
**Strictness ratio** of the form `n/m` means that a call evaluated `n` promises out of `m` promises that were created for it. `0/0` can mean either that a function had no arguments or that it was a built-in etc (had arguments, but they were passed without promises).
</div>

## Call strictness ratios (top 20 within other)

```{r, "call strictness ratios, other top 20", echo=FALSE, fig.width=10, fig.height=4.5}
strict_calls_ratio_other_top20 <- 
  strict_calls_ratio_labelled %>% 
  filter(short=="other") %>% 
  arrange(desc(number)) %>%
  head(20)

ggplot(strict_calls_ratio_other_top20, aes(x=strictness_ratio, y=number)) +
  geom_col() +
  scale_y_continuous(labels=pp_trunc) +
  theme(legend.position="none") +
  ylab("No. of calls") +
  xlab("Ratio of evaluated promises")
```

<div style="font-size: 50%">
**Strictness ratio** of the form `n/m` means that a call evaluated `n` promises out of `m` promises that were created for it. `0/0` can mean either that a function had no arguments or that it was a built-in etc (had arguments, but they were passed without promises).
</div>


## Call strictness ratios (all)

```{r, "call strictness ratios, top 20", echo=FALSE, fig.width=10, fig.height=4.5}
strict_calls_ratio_labelled %>% 
  arrange(desc(number)) %>%
  mutate(number=pp_trunc(number), percent=pp_perc(percent)) %>%
  select(strictness_ratio, number, percent) %>%
  kable(col.names=c( "strictness ratio", "number", "percent"), align="lll")
```

<div style="font-size: 50%">
**Strictness ratio** of the form `n/m` means that a call evaluated `n` promises out of `m` promises that were created for it. `0/0` can mean either that a function had no arguments or that it was a built-in etc (had arguments, but they were passed without promises).
</div>

# Function strictness rate

## Aggregate

```{r, "function strictness rate", echo=FALSE, fig.width=10, fig.height=4.5}
strict_functions_rate <- load_local_csv("aggregated_function_strictness_rate.csv")
  
ggplot(strict_functions_rate %>%
         group_by(strictness_rate) %>% 
         summarise(number=sum(number)), 
       aes(x=strictness_rate, y=number)) +
  geom_col() +
  scale_y_continuous(labels=pp_trunc) +
  scale_x_discrete(
    limit=c(NA, "0","(0,10〉","(10,20〉", "(20,30〉", "(30,40〉", 
            "(40,50〉", "(50,60〉", "(60,70〉","(70,80〉","(80,90〉",
            "(90,100)","100")) +
  theme(legend.position="none") + #, axis.text.x=element_text(angle=90, vjust=.5)) +
  ylab("No. of functions") +
  xlab("Ratio of evaluated promises [%]")
```

```{r, "function strictness rate load", echo=FALSE}
strict_functions_rate <- load_local_csv("function_strictness_rate.csv")
```

<div style="font-size: 50%">
**Strictness rate** reflects what percentage of calls were strict.  
**NA** means the function had no argument.  
**(n,m〉** means the function had between n% and m% strict calls.
</div>

## Function strictness rate, distribution per package/vignette

``` {r, "function strictness rate, per package", echo=FALSE, warning=FALSE, fig.width=10, fig.height=3}
make_graphs_by_range(strict_functions_rate %>% mutate(strictness_rate=ifelse(is.na(strictness_rate),"NA",strictness_rate)), range_column="strictness_rate", max_columns=5)
```

## Function strictness rate, separate results per package/vignette

``` {r, "function strictness rate, separate per package", echo=FALSE, warning=FALSE, fig.width=package_figure_width, fig.height=package_figure_height}
make_graphs_by_split(strict_functions_rate, key="strictness_rate", max_columns=package_figure_columns)
``` 

# Evaluation order

## Aggregate

```{r, "evaluation order", echo=FALSE, fig.width=10, fig.height=4.5}
promise_force_orders <- load_local_csv("aggregated_evaluation_order.csv")

all_possible_force_orders <- 
  tibble(no.of.force.orders=c(0:10,">10")) %>% 
  left_join(promise_force_orders %>% mutate(no.of.force.orders=as.character(no.of.force.orders)), by="no.of.force.orders") %>%
  mutate(number=ifelse(is.na(number), 0, number),
         percent=ifelse(is.na(percent), 0, percent))

ggplot(all_possible_force_orders %>%
      group_by(no.of.force.orders) %>% 
      summarise(number=sum(number)) %>% 
      mutate(percent=100*number/sum(number)), 
    aes(x=no.of.force.orders, y=number)) +
  geom_col() +
  scale_y_continuous(labels=pp_trunc) +
  scale_x_discrete(limit=c(0:10,">10")) +
  theme(legend.position="none") + 
  ylab("No. of functions") +
  xlab("No. of force orders")
```

```{r, "evaluation order load", echo=FALSE}
promise_force_orders <- load_local_csv("evaluation_order.csv")
```

## Evaluation order, distribution per package/vignette

``` {r, "evaluation order, per package", echo=FALSE, warning=FALSE, fig.width=10, fig.height=3}
make_graphs_by_range(promise_force_orders, range_column="no.of.force.orders", max_columns=4)
```

## Evaluation order, separate results per package/vignette

``` {r, "evaluation order, separate per package", echo=FALSE, warning=FALSE, fig.width=package_figure_width, fig.height=package_figure_height}
make_graphs_by_split(promise_force_orders, key="no.of.force.orders", max_columns=package_figure_columns)
``` 

<!--## Argument promise mode
## Argument position laziness (top 20)
## Environment access 
## Default and non-default promise arguments-->

# Calls to specific functions

```{r function-calls-selected-counts, echo=FALSE, comment="", fig.width=10, fig.height=4.5}
#specific_calls <- 
load_local_csv("specific_calls.csv") %>%
  group_by(function_name) %>% 
  summarise(number=sum(number), percent=(100*number/sum(aggregate_basic_info$n.calls))) %>%
  arrange(desc(number)) %>%
  mutate(number=pp_trunc(number), percent=pp_perc(percent)) %>%
  kable(col.names=c("function","number","percentage"), align="lrr")

# ggplot(specific_calls, aes(x=function_name, y=number)) +
#   geom_col() +
#   scale_y_continuous(labels=pp_trunc) +
#   theme(legend.position="none", axis.text.x=element_text(angle=90, vjust=.5, hjust=1, size=4)) +
#   ylab("No. of calls") +
#   xlab("Function")
```
