---
title: "On the Design, Implementation and Use of Laziness in R"
output:
  html_document:
    theme: cerulean
    toc: true
    toc_float: true
    collapsed: true
    smooth_scroll: false
    number_sections: true
params:
    summarized_data_dirpath: ""
    visualized_data_dirpath: ""
    latex_macro_filepath: ""
---

```{r results = "asis", echo = FALSE}
cat("
<style>
div.section {
  text-align: justify;
  text-justify: inter-word;
}
</style>
")
```

```{r echo = FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(fig.width = 12, fig.height = 4) 

library(tidyverse)
library(ggplot2)

PETA <- 10^15
TERA <- 10^12
GIGA <- 10^9
MEGA <- 10^6
KILO <- 10^3
HECTO <- 10^2
DECA <- 10^1
DECI <- 10^-1
CENTI <- 10^-2
MILLI <- 10^-3
MICRO <- 10^-6
NANO <- 10^-9
PICO <- 10^-12
SECONDS_PER_MINUTE <- 60
MINUTES_PER_HOUR <- 60
HOURS_PER_DAY <- 24
SECONDS_PER_HOUR <- SECONDS_PER_MINUTE * MINUTES_PER_HOUR
SECONDS_PER_DAY <- HOURS_PER_DAY * SECONDS_PER_HOUR

paste_round <- function(value, div, digits, suffix, sep = " ") {
    paste(round(value/div, digits), suffix, sep = sep)
}

memory_size_labels <-  function(x, digits = 1) {
    ifelse(x == 0, "0 B",
           { y <- log2(x)
             units <- c("B", "KB", "MB", "GB", "TB", "PB")
             unit <- units[y %/% 10 + 1]
             value <- 2 ^ (y %% 10)
             paste(round(value, digits), unit, sep = " ") })
  }

count_labels <- Vectorize(function(x, digits = 2) 
    if(is.na(x))       "NA"
    else if(x < 10^3)  paste0(x)
    else if(x < 10^6)  paste_round(x, 1000, digits, "K")
    else if(x < 10^9)  paste_round(x, 10^6, digits, "M")
    else if(x < 10^12) paste_round(x, 10^9, digits, "B")
    else               paste_round(x, 10^12, digits, "T"),
  "x")

relative_labels <- function(x) percent_labels(x * 100)
percent_labels <-  function(x) paste0(x, "%", sep="")
  
time_labels <- Vectorize(function(x, digits = 1)
   if (is.na(x))                   "NA"
   else if (x < NANO)              paste_round(x, PICO, digits, "ps")
   else if (x < MICRO)             paste_round(x, NANO, digits, "ns")
   else if (x < MILLI)             paste_round(x, MICRO, digits, "Î¼s")
   else if(x < 1)                  paste_round(x, MILLI, digits, "ms")
   else if(x < SECONDS_PER_MINUTE) paste_round(x, 1, digits, "s")
   else if(x < SECONDS_PER_HOUR)   paste_round(x, SECONDS_PER_MINUTE, digits, "mins")
   else if(x < SECONDS_PER_DAY)    paste_round(x, SECONDS_PER_HOUR, digits, "hours")
   else                            paste_round(x, SECONDS_PER_DAY, digits, "days"),
  "x")

format_as_percentage <- function(x, digits = 1) {
    rounded <- round(x, digits = digits)
    first_decimal_digit = as.integer(rounded * 10) %% 10
    str_c(format(100 * x,
                 digits = digits,
                 nsmall = first_decimal_digit != 0,
                 scientific = FALSE), "%")
}

format_as_absolute <- function(x, digits = 1) count_labels(x, digits)

format_as_size <- function(x, digits = 1) memory_size_labels(x, digits)

format_as_code <- function(x) paste0("\\code{", x,  "}")

read_table <- function(filename, binary = TRUE, compression_level = 3) {
    read_data_table(path(params$summarized_data_dirpath, filename),
                    binary = binary, 
                    compression_level = compression_level)
}

save_local_graph <- function(plot, name, device = "pdf", ...) {
    ggsave(filename = file.path(params$visualized_data_dirpath, name),
           plot = plot, device = device, ...)
    plot
}

show_table <- function(tablename) {
    read_csv(tablename, col_names = TRUE) %>%
    datatable(fillContainer = TRUE, filter = "top")
}

show_graph <- function(graphname) include_graphics(graphname)

show_two_graphs <- function(first_graphname, second_graphname) {
    load_graph <- function(graphname) {
        grid::rasterGrob(as.raster(readPNG(graphname)), interpolate = TRUE)
    }
    grid.arrange(load_graph(first_graphname),
                 load_graph(second_graphname),
                 ncol = 2)
}

old_theme <- theme_set(theme_bw() + theme(text = element_text(size = 15), panel.border = element_blank()))

# Latex Macro Generation
## name prefix is one of:
## - Perc - adds a % at the end
## - Count - adds labels like K, M, B for Kilo, Million and Billion
## - Size - adds lables like KB, MB, GB for memory sizes
## - Code - wraps the value in \code{}
## - Text - content is as is
generate_macro <- function(macro_name, value, subst = FALSE) {
    if(subst) {
        name <- as.character(substitute(macro_name))
    } else {
        name <- macro_name
    }
    if (str_sub(name, 1, 4) == "Perc")      formatted_value <- format_as_percentage(value)
    else if(str_sub(name, 1, 5) == "Count") formatted_value <- format_as_absolute(value)
    else if(str_sub(name, 1, 4) == "Size")  formatted_value <- format_as_size(value)
    else if(str_sub(name, 1, 4) == "Code")  formatted_value <- format_as_code(value)
    else if(str_sub(name, 1, 4) == "Text")  formatted_value <- format_as_code(value)
    else stop(str_c("Unidentified name", name, sep = " "))
    formatted_value <- str_replace(formatted_value, "\\%", "\\\\%")
    definition <- str_glue("\\newcommand {{\\{name}}} {{{formatted_value}\\xspace}} %% {value}")
    write_lines(definition, params$latex_macro_filepath, append = TRUE)
}

summarize_outliers <- function(df, grouping_column,
                               count_column, relative_count_column,
                               outlier_value) {

    grouping_column <- enquo(grouping_column)
    count_column <- enquo(count_column)
    relative_count_column <- enquo(relative_count_column)

    outlier_row <-
        df %>%
        filter(!! grouping_column > outlier_value) %>%
        mutate(!!count_column := as.numeric(!!count_column)) %>%
        summarize(!!grouping_column := str_c(">", toString(outlier_value), sep = " "),
                  !!count_column := sum(!!count_column),
                  !!relative_count_column := sum(!!relative_count_column))

    df <-
        df %>%
        mutate(!! grouping_column := as.character(!! grouping_column)) %>%
        bind_rows(outlier_row)

    df
}

bar <- function(widths, total, labels) {
    options(device = cairo_pdf)
    ## If you want to draw arbitrary rectangles, use geom_tile() or geom_rect()
    xmin <- cumsum(c(0, head(widths, -1)))
    df <- data.frame(
        xmin = xmin,
        xmax = cumsum(widths),
        ymin = -0.5,
        ymax = 0.5,
        fill = factor(labels), #factor(1:length(widths)),
        label = labels,
        xmid = widths/2.0 + xmin,
        ymid = 0
    )

    plot <-
        df %>%
        ggplot() +
        geom_rect(aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = fill)) +
        geom_text(aes(label = label, x = xmid, y = ymid), colour = "white") +
        scale_y_continuous() +
        scale_x_continuous(breaks = cumsum(widths),
                           labels = relative_labels,
                           sec.axis = sec_axis(trans = ~ . * total,
                                               breaks = cumsum(widths),
                                               labels = count_labels)) +
        theme(axis.text.y = element_blank(),
              axis.ticks = element_blank(),
              panel.grid.minor = element_blank(),
              panel.grid.major = element_blank(),
              legend.position = "none") +
        labs(x = "", y = "")
plot
}

```

```{r echo = TRUE, warning=FALSE, message=FALSE}
argument_promise_count_by_call_depth <- read_table("argument_promise_count_by_call_depth")
argument_promise_count_by_forcing_scope <- read_table("argument_promise_count_by_forcing_scope")

event_counts <- read_table("event_counts")
summarized_event_counts <- 
    read_table("summarized_event_counts") %>%
    arrange(desc(count))

extreme_event_counts <- read_table("extreme_event_counts")
event_processing_rates <- read_table("event_processing_rates")
         
substitute_class_summary <- read_table("substitute_class_summary")
non_same_scope_substitute_calls <- read_table("non_same_scope_substitute_calls")

promise_lifecycle_summary <- read_table("promise_lifecycle_summary")
promise_lifecycle_list <- read_table("promise_lifecycle_list")

context_sensitive_lookup_summary <- read_table("context_sensitive_lookup_summary")
context_sensitive_lookup_symbols <- read_table("context_sensitive_lookup_symbols")

promise_gc_summary <- read_table("promise_gc_summary")
promise_gc_distribution_by_type <- read_table("promise_gc_distribution_by_type")

promise_argument_forced_by_promise_argument <- read_table("promise_argument_forced_by_promise_argument")
promise_argument_returning_non_locally <- read_table("promise_argument_returning_non_locally")

created_side_effects <- read_table("created_side_effects")
observed_side_effects <- read_table("observed_side_effects")
```

# Events

```{r, eval = TRUE, echo = FALSE}
datatable(summarized_event_counts)

event_graph <-
    bar(summarized_event_counts$count, sum(summarized_event_counts$count), summarized_event_counts$event)
    
save_local_graph(event_graph, "event_graph.pdf", width=12, height=2.5)
```

# Substitute Summary

```{r, eval = TRUE, echo = FALSE}
datatable(substitute_class_summary)

PercCallerEnvSubstituteCalls <-
    substitute_class_summary %>%
    filter(substitute_class == "SameScope") %>%
    pull(relative_call_count)
generate_macro("PercCallerEnvSubstituteCalls", PercCallerEnvSubstituteCalls)

PercNewEnvSubstituteCalls <-
    substitute_class_summary %>%
    filter(substitute_class == "NewScope") %>%
    pull(relative_call_count)
generate_macro("PercNewEnvSubstituteCalls", PercNewEnvSubstituteCalls)

CountDynamicEnvSubstituteCalls <-
    substitute_class_summary %>%
    filter(substitute_class %in% c("DynamicScope", "StaticScope")) %>%
    pull(call_count) %>%
    sum()
generate_macro("CountDynamicEnvSubstituteCalls", CountDynamicEnvSubstituteCalls)

datatable(non_same_scope_substitute_calls)
```

# Promise Lifecycle

```{r, eval = TRUE, echo = FALSE}
alphabetical_row_names = c(letters, toupper(letters))

datatable(promise_lifecycle_summary)

CountLifecycleTotal <-
    promise_lifecycle_summary %>% 
    pull(total_lifecycle_count) %>%
    first()

generate_macro("CountLifecycleTotal", CountLifecycleTotal)

CountLifecycleUnescapedArguments <-
    promise_lifecycle_summary %>% 
    filter(argument, !escaped) %>% 
    pull(lifecycle_count)

generate_macro("CountLifecycleUnescapedArguments", CountLifecycleUnescapedArguments)

CountLifecycleEscapedArguments <-
    promise_lifecycle_summary %>% 
    filter(argument, escaped) %>% 
    pull(lifecycle_count)

generate_macro("CountLifecycleEscapedArguments", CountLifecycleEscapedArguments)

CountLifecycleNonArguments <-
    promise_lifecycle_summary %>% 
    filter(!argument) %>% 
    pull(lifecycle_count)

generate_macro("CountLifecycleNonArguments", CountLifecycleNonArguments)

decode_sequence <- function(seq) {
        unlist(str_split(str_sub(seq, 2, -2), " "))
}
    
expand_lifecycle <- function(action, count) {
    if(action == "()") {
        ""
    } else {
        action_seq <- decode_sequence(action)
        count_seq <- decode_sequence(count)
        str_c(rep(action_seq, count_seq), collapse = " ")
    }
}

promise_lifecycle_list <-
    promise_lifecycle_list %>%
    mutate(event = map2_chr(action, count, expand_lifecycle)) %>%
    select(-action, -count, -promise_count)

escaped_argument_list <-
    promise_lifecycle_list %>%
    filter(argument, escaped)

datatable(escaped_argument_list)

escaped_argument_list %>%
    select(event, relative_promise_count) %>%
    arrange(desc(relative_promise_count)) %>%
    slice(1:10) %>%
    mutate(index = alphabetical_row_names[dplyr::row_number()]) %>%
    pmap(function(event, relative_promise_count, index) {
        name <- str_c("TextLifecycleEscapedArguments", index)
        generate_macro(name, event)
        name <- str_c("PercLifecycleEscapedArguments", index)
        generate_macro(name, relative_promise_count)
    })


unescaped_argument_list <-
    promise_lifecycle_list %>%
    filter(argument, !escaped)
    
datatable(unescaped_argument_list)

unescaped_argument_list %>%
    select(event, relative_promise_count) %>%
    arrange(desc(relative_promise_count)) %>%
    slice(1:10) %>%
    mutate(index = alphabetical_row_names[dplyr::row_number()]) %>%
    pmap(function(event, relative_promise_count, index) {
        name <- str_c("TextLifecycleUnescapedArguments", index)
        generate_macro(name, event)
        name <- str_c("PercLifecycleUnescapedArguments", index)
        generate_macro(name, relative_promise_count)
    })

non_argument_list <-
    promise_lifecycle_list %>%
    filter(!argument)
    
datatable(non_argument_list)

non_argument_list %>%
    select(event, relative_promise_count) %>%
    arrange(desc(relative_promise_count)) %>%
    slice(1:10) %>%
    mutate(index = alphabetical_row_names[dplyr::row_number()]) %>%
    pmap(function(event, relative_promise_count, index) {
        name <- str_c("TextLifecycleNonArguments", index)
        generate_macro(name, event)
        name <- str_c("PercLifecycleNonArguments", index)
        generate_macro(name, relative_promise_count)
    })

```

# Context Sensitive Lookup

```{r, eval = TRUE, echo = FALSE}
datatable(context_sensitive_lookup_summary)

context_sensitive_binding_lookup <- 
    context_sensitive_lookup_summary %>%
    pull(binding_lookup) %>%
    sum()
generate_macro("CountConSenBndgLkp", context_sensitive_binding_lookup)

context_sensitive_argument_binding_lookup_failure <- 
    context_sensitive_lookup_summary %>%
    filter(argument & !success) %>%
    pull(binding_lookup) %>%
    sum()
generate_macro("CountConSenArgBndgLkpFailure", context_sensitive_argument_binding_lookup_failure)

context_sensitive_argument_force <-
    context_sensitive_lookup_summary %>% 
    filter(argument) %>% 
    pull(forced) %>% 
    sum()
generate_macro("CountConSenArgForce", context_sensitive_argument_force)
    
context_sensitive_argument_force_successful <-
    context_sensitive_lookup_summary %>% 
    filter(argument & success) %>% 
    pull(forced) %>% 
    sum()
generate_macro("CountConSenArgForceSuccess", context_sensitive_argument_force_successful)
generate_macro("PercConSenArgForceSuccess", context_sensitive_argument_force_successful/context_sensitive_argument_force)

context_sensitive_argument_force_failure <-
    context_sensitive_lookup_summary %>% 
    filter(argument & !success) %>% 
    pull(forced) %>% 
    sum()
generate_macro("CountConSenArgForceFailure", context_sensitive_argument_force_failure)
generate_macro("PercConSenArgForceFailure", context_sensitive_argument_force_failure / context_sensitive_argument_force)

context_sensitive_lookup_symbols <-
    context_sensitive_lookup_symbols %>%
    filter(formal_parameter_position != -1)

symbol_overload_table <-
    context_sensitive_lookup_symbols %>%
    filter(argument) %>%
    group_by(symbol) %>%
    summarize(count = n_distinct(function_id, formal_parameter_position)) %>%
    ungroup() %>%
    arrange(desc(count))

context_sensitive_overloaded_parameter_count <-
    context_sensitive_lookup_symbols %>%
    distinct(function_id, formal_parameter_position) %>%
    nrow()
generate_macro("CountConSenParameter", context_sensitive_overloaded_parameter_count)

context_sensitive_overloaded_function_count <-
    context_sensitive_lookup_symbols %>%
    distinct(function_id) %>%
    nrow()
generate_macro("CountConSenFunction", context_sensitive_overloaded_function_count)

row_names <- c(letters, toupper(letters))

symbol_overload_table %>%
    slice(1:30) %>%
    mutate(index = row_names[dplyr::row_number()]) %>%
    pmap(function(index, symbol, count) {
        generate_macro(paste0("CodeConSenSymbol", index), symbol)
        generate_macro(paste0("CountConSenSymbol", index), count)
    })

datatable(symbol_overload_table)
```

# Promise GC 

```{r, eval = TRUE, echo = FALSE}
datatable(promise_gc_summary)

AllGcPromises <-
    promise_gc_summary %>%
    pull(promise_count) %>%
    sum()

CountSingleGcPromises <-
    promise_gc_summary %>%
    filter(single_gc_cycle) %>%
    pull(promise_count) %>%
    sum()
generate_macro("PercSingleGCPromises", CountSingleGcPromises/AllGcPromises)

CountMultipleGcPromises <-
    promise_gc_summary %>%
    filter(!single_gc_cycle) %>%
    pull(promise_count) %>%
    sum()
generate_macro("PercMultipleGcPromises", CountMultipleGcPromises/AllGcPromises)

CountMultipleGcEscapedArgumentPromises <-
    promise_gc_summary %>%
    filter(!single_gc_cycle & escaped & argument) %>%
    pull(promise_count) %>%
    sum()
generate_macro("PercMultipleGcEscapedArgumentPromises", CountMultipleGcEscapedArgumentPromises/CountMultipleGcPromises)

CountMultipleGcUnescapedArgumentPromises <-
    promise_gc_summary %>%
    filter(!single_gc_cycle & argument & !escaped) %>%
    pull(promise_count) %>%
    sum()
generate_macro("PercMultipleGcUnescapedArgumentPromises", CountMultipleGcUnescapedArgumentPromises/CountMultipleGcPromises)

CountMultipleGcNonArgumentPromises <-
    promise_gc_summary %>%
    filter(!single_gc_cycle & !argument) %>%
    pull(promise_count) %>%
    sum()
generate_macro("PercMultipleGcNonArgumentPromises", CountMultipleGcNonArgumentPromises/CountMultipleGcPromises)

datatable(promise_gc_distribution_by_type)
```

# Side Effects

```{r, eval = TRUE, echo = FALSE}

CountEffectPromises <-
    created_side_effects %>%
    pull(count) %>%
    sum()
    
generate_macro("CountEffectPromises", CountEffectPromises)


CountEffectSamePromises <-
    created_side_effects %>%
    filter(mode == "S") %>%
    pull(count) %>%
    sum()
    
generate_macro("CountEffectSamePromises", CountEffectSamePromises)
generate_macro("PercEffectSamePromises", CountEffectSamePromises / CountEffectPromises)


CountEffectOtherPromises <-
    created_side_effects %>%
    filter(mode == "O") %>%
    pull(count) %>%
    sum()
    
generate_macro("CountEffectOtherPromises", CountEffectOtherPromises)
generate_macro("PercEffectOtherPromises", CountEffectOtherPromises / CountEffectPromises)

CountEffectLexicalPromises <-
    created_side_effects %>%
    filter(mode == "L") %>%
    pull(count) %>%
    sum()
    
generate_macro("CountEffectLexicalPromises", CountEffectLexicalPromises)
generate_macro("PercEffectLexicalPromises", CountEffectLexicalPromises / CountEffectPromises)
```
## Direct & Same Environment

```{r, eval = TRUE, echo = FALSE}

direct_S_created_side_effects <-
    created_side_effects %>%
    filter(direct & mode == "S") %>%
    arrange(desc(count))

datatable(direct_S_created_side_effects)

CountEffectDirectSamePromises <-
    direct_S_created_side_effects %>%
    pull(count) %>%
    sum()

generate_macro("PercEffectDirectSamePromises", CountEffectDirectSamePromises / CountEffectSamePromises)
```

## Indirect & Same Environment

```{r, eval = TRUE, echo = FALSE}
indirect_S_created_side_effects <-
    created_side_effects %>%
    filter(!direct & mode == "S") %>%
    arrange(desc(count))

datatable(indirect_S_created_side_effects)

CountEffectIndirectSamePromises <-
    indirect_S_created_side_effects %>%
    pull(count) %>%
    sum()

generate_macro("PercEffectIndirectSamePromises", CountEffectIndirectSamePromises / CountEffectSamePromises)
```

## Direct & Other Environment

```{r, eval = TRUE, echo = FALSE}
direct_O_created_side_effects <-
    created_side_effects %>%
    filter(direct & mode == "O") %>%
    arrange(desc(count))

datatable(direct_O_created_side_effects)

CountEffectDirectOtherPromises <-
    direct_O_created_side_effects %>%
    pull(count) %>%
    sum()

generate_macro("PercEffectDirectOtherPromises", CountEffectDirectOtherPromises / CountEffectOtherPromises)
```

## Indirect & Other Environment

```{r, eval = TRUE, echo = FALSE}
indirect_O_created_side_effects <-
    created_side_effects %>%
    filter(!direct & mode == "O") %>%
    arrange(desc(count))

datatable(indirect_O_created_side_effects)

CountEffectIndirectOtherPromises <-
    indirect_O_created_side_effects %>%
    pull(count) %>%
    sum()

generate_macro("PercEffectIndirectOtherPromises", CountEffectIndirectOtherPromises / CountEffectOtherPromises)
```

## Direct & Lexical Parent Environment

```{r, eval = TRUE, echo = FALSE}
direct_L_created_side_effects <-
    created_side_effects %>%
    filter(direct & mode == "L") %>%
    arrange(desc(count))

datatable(direct_L_created_side_effects)

CountEffectDirectLexicalPromises <-
    direct_L_created_side_effects %>%
    pull(count) %>%
    sum()

generate_macro("PercEffectDirectLexicalPromises", CountEffectDirectLexicalPromises / CountEffectLexicalPromises)
```

## Indirect & Lexical Parent Environment

```{r, eval = TRUE, echo = FALSE}
indirect_L_created_side_effects <-
    created_side_effects %>%
    filter(!direct & mode == "L") %>%
    arrange(desc(count))

datatable(indirect_L_created_side_effects)

CountEffectIndirectLexicalPromises <-
    indirect_L_created_side_effects %>%
    pull(count) %>%
    sum()

generate_macro("PercEffectIndirectLexicalPromises", CountEffectIndirectLexicalPromises / CountEffectLexicalPromises)
```
##datatable(observed_side_effects)
```

# Evaluation Call Depth

```{r, eval = TRUE, echo = FALSE}

datatable(argument_promise_count_by_call_depth)

## remove non-argument and escaped promises
argument_promise_count_by_call_depth <-
    argument_promise_count_by_call_depth %>%
    filter(call_depth != "-1")

CountPromiseAllDepth <-
    argument_promise_count_by_call_depth %>%
    pull(promise_count) %>%
    sum()

CountPromiseZeroDepth <-
    argument_promise_count_by_call_depth %>%
    filter(call_depth == "0") %>%
    pull(promise_count) %>%
    sum()
generate_macro("PercPromiseZeroDepth", CountPromiseZeroDepth / CountPromiseAllDepth)
    
CountPromiseOneDepth <-
    argument_promise_count_by_call_depth %>%
    filter(call_depth == "1") %>%
    pull(promise_count) %>%
    sum()
generate_macro("PercPromiseOneDepth", CountPromiseOneDepth / CountPromiseAllDepth)
    
CountPromiseMultipleDepth <-
    argument_promise_count_by_call_depth %>%
    filter(call_depth != "0" & call_depth != "1") %>%
    pull(promise_count) %>%
    sum()
generate_macro("PercPromiseMultipleDepth", CountPromiseMultipleDepth / CountPromiseAllDepth)

total_count <-  sum(argument_promise_count_by_call_depth$promise_count)

argument_promise_call_depth_graph <-
    argument_promise_count_by_call_depth %>%
    filter(call_depth %in% c(1:5, "> 5")) %>%
    ggplot(aes(call_depth, relative_promise_count)) +
    geom_col() +
    scale_x_discrete(limits = c(1:5, "> 5")) +
    scale_y_continuous(sec.axis = sec_axis(~ . * total_count,
                                           labels = count_labels),
                       labels = relative_labels) +
    labs(x = "", y = "") + 
    coord_flip()
    
save_local_graph(argument_promise_call_depth_graph, "forcedepth.pdf", width=12, height=2.5)
```

# Mutually Forcing Argument Promises

```{r, eval = TRUE, echo = FALSE}
datatable(promise_argument_forced_by_promise_argument)

CountMutualForcing <-
    sum(promise_argument_forced_by_promise_argument$count)

generate_macro("CountMutualForcing", CountMutualForcing)

CountMutualForcingFunctions <-
    n_distinct(promise_argument_forced_by_promise_argument$function_id)

generate_macro("CountMutualForcingFunctions", CountMutualForcingFunctions)

CountMutualForcingArgumentPositions <-
    n_distinct(promise_argument_forced_by_promise_argument$function_id, 
               promise_argument_forced_by_promise_argument$forcing_actual_argument_position)

generate_macro("CountMutualForcingArgumentPositions", CountMutualForcingArgumentPositions)

CountMutualForcedArgumentPositions <-
    n_distinct(promise_argument_forced_by_promise_argument$function_id, 
               promise_argument_forced_by_promise_argument$formal_parameter_position)

generate_macro("CountMutualForcedArgumentPositions", CountMutualForcedArgumentPositions)
```

# Non local returning promises

```{r, eval = TRUE, echo = FALSE}
datatable(promise_argument_returning_non_locally)
```

# Promise Dispatch Force

```{r, eval = TRUE, echo = FALSE}

s3_promise_force <-
    argument_promise_count_by_forcing_scope %>%
    filter(forcing_scope == "S3") %>%
    pull(promise_count) %>%
    sum()
generate_macro("CountSThreePromiseForce", s3_promise_force)

s4_promise_force <-
    argument_promise_count_by_forcing_scope %>%
    filter(forcing_scope == "S4") %>%
    pull(promise_count) %>%
    sum()
generate_macro("CountSFourPromiseForce", s4_promise_force)

datatable(argument_promise_count_by_forcing_scope)
```

TODO:
- 1. Promise Evaluation Depth
- 2. Mutually forcing argument promises
- 3. Non local returning promise arguments
- 4. Validation of these cases
- 5. Fix Side Effect data and analysis
- 6. Number of promises forced by dispatch
- 7. Kind of expression in unbound promises

- 9. Add event count bar
- 8. Add time measurement to all R analyses
- 12. Move summarize outliers form summary.R to the analysis report.
      Add summarize outliers line to the report and make sure the analysis is correct.

- 10. Add figure showing data/files/time at each step of analysis
- 11. Add figure showing how reduce/combine etc. work
